<template>
    <site-nav></site-nav>
    <canvas id="renderer"></canvas>
</template>

<script lang="ts">
    export default class SpaceInvadersElement extends HTMLElement {
    static tag = 'x-space-invaders';
    static shadow = true;
    // --- 1. Class Properties (Component State) ---
    canvas: HTMLCanvasElement | null = null;
    ctx: CanvasRenderingContext2D | null = null;
    width = 800;
    height = 600;

    // Player
    player = { x: 0, y: 0, w: 40, h: 12, speed: 300 };
    playerBullets: Array<any> = [];

    // Enemies
    enemies: Array<any> = [];
    enemyDirection = 1; // 1 right, -1 left
    enemySpeed = 30; // px per second
    enemyDrop = 20;

    // Game state
    lastTime = 0;
    running = false;
    keys: Record<string, boolean> = {};
    score = 0;
    lives = 3;
    level = 1;

    // Reference to the key handler for removal
    handleKeyDown = (e: KeyboardEvent) => { this.keys[e.code] = true; };
    handleKeyUp = (e: KeyboardEvent) => { this.keys[e.code] = false; };

    // --- 2. Constructor and Lifecycle Hooks ---

    constructor() {
        super();
        if ((this.constructor as any).shadow) {
            this.attachShadow({ mode: 'open' });
        }
    }

    connectedCallback() {
        if (!this.shadowRoot.innerHTML.trim()) {
            this.shadowRoot.innerHTML = `
                <style>
                    :host { display: block; width: 100%; height:90vh; background: #000; overflow: hidden; color: #fff; }
                    .hud { display:flex; justify-content:space-between; align-items:center; padding:8px 12px; font-family: monospace; }
                    canvas { display: block; margin: 0 auto; background: #000; border: 2px solid #222; }
                    .center { text-align:center; color:#fff; }
                    .overlay { position:absolute; left:0; right:0; top:0; pointer-events:none }
                </style>
                <div class="hud">
                    <div>Score: <span id="score">0</span></div>
                    <div>Lives: <span id="lives">3</span></div>
                    <div>Level: <span id="level">1</span></div>
                </div>
                <canvas id="renderer" width="800" height="600"></canvas>
            `;
        }

        this.canvas = this.shadowRoot.querySelector('#renderer');
        this.ctx = this.canvas.getContext('2d');

        this.resize();
        window.addEventListener('resize', () => this.resize());

        window.addEventListener('keydown', this.handleKeyDown);
        window.addEventListener('keyup', this.handleKeyUp);

        this.init();
    }

    disconnectedCallback() {
        this.running = false;
        window.removeEventListener('keydown', this.handleKeyDown);
        window.removeEventListener('keyup', this.handleKeyUp);
    }

    resize() {
        // keep canvas internal size stable; scale with CSS if needed
        if (!this.canvas) return;
        const rect = this.canvas.getBoundingClientRect();
        this.width = this.canvas.width = 800;
        this.height = this.canvas.height = 600;
    }

    init() {
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.player.x = this.width / 2 - this.player.w / 2;
        this.player.y = this.height - 60;
        this.playerBullets = [];
        this.spawnEnemies();

        this.running = true;
        this.lastTime = performance.now();
        requestAnimationFrame(this.loop.bind(this));
    }

    spawnEnemies() {
        this.enemies = [];
        const rows = 4 + Math.min(2, this.level - 1);
        const cols = 10;
        const spacingX = 52;
        const spacingY = 40;
        const startX = (this.width - (cols - 1) * spacingX) / 2;
        const startY = 60;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                this.enemies.push({
                    x: startX + c * spacingX,
                    y: startY + r * spacingY,
                    w: 34,
                    h: 20,
                    alive: true,
                    row: r,
                    col: c
                });
            }
        }
    }

    loop(now: number) {
        if (!this.running) return;
        const dt = Math.min(0.05, (now - this.lastTime) / 1000);
        this.lastTime = now;

        this.update(dt);
        this.render();

        requestAnimationFrame(this.loop.bind(this));
    }

    update(dt: number) {
        // Player movement
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
            this.player.x -= this.player.speed * dt;
        }
        if (this.keys['ArrowRight'] || this.keys['KeyD']) {
            this.player.x += this.player.speed * dt;
        }
        this.player.x = Math.max(0, Math.min(this.width - this.player.w, this.player.x));

        // Shooting
        if (this.keys['Space'] || this.keys['KeyK']) {
            this.firePlayerBullet();
        }

        // Update bullets
        for (let i = this.playerBullets.length - 1; i >= 0; i--) {
            const b = this.playerBullets[i];
            b.y -= b.speed * dt;
            if (b.y + b.h < 0) this.playerBullets.splice(i, 1);
        }

        // Update enemies: move horizontally; if any hits border, reverse and drop
        let hitBorder = false;
        const leftMost = Math.min(...this.enemies.filter(e=>e.alive).map(e=>e.x), this.width);
        const rightMost = Math.max(...this.enemies.filter(e=>e.alive).map(e=>e.x + e.w), 0);
        if (leftMost <= 10 && this.enemyDirection === -1) hitBorder = true;
        if (rightMost >= this.width - 10 && this.enemyDirection === 1) hitBorder = true;

        for (const e of this.enemies) {
            if (!e.alive) continue;
            e.x += this.enemyDirection * this.enemySpeed * dt;
            if (hitBorder) e.y += this.enemyDrop;
        }
        if (hitBorder) this.enemyDirection *= -1;

        // collisions: bullets vs enemies
        for (let i = this.playerBullets.length - 1; i >= 0; i--) {
            const b = this.playerBullets[i];
            for (const e of this.enemies) {
                if (!e.alive) continue;
                if (this.rectsOverlap(b, e)) {
                    e.alive = false;
                    this.playerBullets.splice(i, 1);
                    this.score += 10 + (4 - e.row) * 2;
                    this.updateHUD();
                    break;
                }
            }
        }

        // Check if enemies reach player
        for (const e of this.enemies) {
            if (!e.alive) continue;
            if (e.y + e.h >= this.player.y) {
                this.lives -= 1;
                this.updateHUD();
                if (this.lives <= 0) return this.gameOver();
                this.resetRound();
                return;
            }
        }

        // Win condition: all dead
        if (this.enemies.every(e => !e.alive)) {
            this.level += 1;
            this.enemySpeed += 10;
            this.spawnEnemies();
            this.updateHUD();
        }
    }

    rectsOverlap(a: any, b: any) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    firePlayerBullet() {
        // small rate limit
        const now = performance.now();
        if ((this as any)._lastShot && now - (this as any)._lastShot < 220) return;
        (this as any)._lastShot = now;

        this.playerBullets.push({ x: this.player.x + this.player.w / 2 - 3, y: this.player.y - 8, w: 6, h: 10, speed: 420 });
    }

    resetRound() {
        this.player.x = this.width / 2 - this.player.w / 2;
        this.playerBullets = [];
        this.spawnEnemies();
    }

    gameOver() {
        this.running = false;
        this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
        this.ctx.fillRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '36px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.width / 2, this.height / 2 - 10);
        this.ctx.font = '18px monospace';
        this.ctx.fillText(`Score: ${this.score}`, this.width / 2, this.height / 2 + 24);

        setTimeout(() => {
            // auto restart after short delay
            this.init();
        }, 1500);
    }

    updateHUD() {
        const scoreEl = this.shadowRoot.querySelector('#score');
        const livesEl = this.shadowRoot.querySelector('#lives');
        const levelEl = this.shadowRoot.querySelector('#level');
        if (scoreEl) scoreEl.textContent = String(this.score);
        if (livesEl) livesEl.textContent = String(this.lives);
        if (levelEl) levelEl.textContent = String(this.level);
    }

    render(){
        if (!this.ctx || !this.canvas) return;
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.width, this.height);

        // draw background stars
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,this.width,this.height);

        // draw player
        ctx.fillStyle = '#0f0';
        roundRect(ctx, this.player.x, this.player.y, this.player.w, this.player.h, 3, true, false);

        // draw player bullets
        ctx.fillStyle = '#ff0';
        for (const b of this.playerBullets) {
            ctx.fillRect(Math.round(b.x), Math.round(b.y), b.w, b.h);
        }

        // draw enemies
        for (const e of this.enemies) {
            if (!e.alive) continue;
            ctx.fillStyle = '#f55';
            ctx.fillRect(Math.round(e.x), Math.round(e.y), e.w, e.h);
            // eyes
            ctx.fillStyle = '#111';
            ctx.fillRect(Math.round(e.x + 6), Math.round(e.y + 6), 6, 6);
            ctx.fillRect(Math.round(e.x + e.w - 12), Math.round(e.y + 6), 6, 6);
        }

        // HUD is in DOM
    }
}

function roundRect(ctx: CanvasRenderingContext2D, x:number, y:number, w:number, h:number, r:number, fill:boolean, stroke:boolean){
    if (r === undefined) r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
}

declare global {
    interface Window { requestAnimationFrame: any }
}

export {};

</script>

<style lang="scss">
    :host {
        display: block;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
    }
</style>

<route path="/space" methods="GET" />