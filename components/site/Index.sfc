<template>
  <site-nav></site-nav>
  <div class="panel">
    <h2>What is SFC?</h2>
    <p>
      SFC is a powerful way to build web components
      using a single file structure that includes template, script, and style.
      This example is built with SFC components!
    </p>
        <h3>Quick Start - Create a component</h3>
        <code-block lang="markup">&lt;template&gt;
    &lt;div class="my-component"&gt;
        &lt;h2&gt;Hello, SFC!&lt;/h2&gt;
        &lt;p&gt;This is my first SFC component.&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts"&gt;
export default {
    tag: "my-component",
    shadow: true,
    connectedCallback() {
        console.log("My component is connected!");
    }
&lt;/script&gt;
&lt;style lang="scss"&gt;
.my-component {
    padding: 1rem;
    background-color: #f0f0f0;

    h2 {
        color: #333;
    }
    p {
        color: #666;
    }
}
&lt;/style&gt;</code-block>
    </div>
    <div class="panel">
        <h3>Code Block Component</h3>
        <p>Use the <code>&lt;code-block&gt;</code> component for syntax highlighting. Specify the language with the <code>lang</code> attribute.</p>
        <code-block lang="markup">
&lt;template&gt;
  &lt;div&gt;Hello World&lt;/div&gt;
&lt;/template&gt;
&lt;script lang="ts"&gt;
export default {
  tag: "hello-world",
  shadow: true
}
&lt;/script&gt;
        </code-block>
    </div>
    <div class="panel">
        <h3>Routing</h3>
        <p>
          Use the <code>&lt;route&gt;</code> tag to declare routes for components. You
          may list multiple HTTP methods (comma separated) and use dynamic segments
          with <code>/:param</code> â€” those params are available on the instance as
          <code>this.params</code>.
        </p>
        <p>
          Want to learn about the shared styling system used across this demo? See the <a href="/site/global-styles">Global Styles guide</a> for details and examples of using <code>&lt;style global&gt;</code>.
        </p>
        <code-block lang="markup">&lt;route path="/my-component" methods="GET" lazy="component" /&gt;</code-block>

        <h3>POST routes</h3>
        <p>
          POST routes accept request bodies (form data or JSON). In dev the Vite
          middleware will call a <code>postHandler(body, req, res)</code> exported
          from the component (object export or class method). The instance will
          also receive the parsed payload on <code>this.postData</code> so client
          code can react when it's mounted.
        </p>
        <code-block lang="markup">&lt;route path="/product/add" methods="POST" /&gt;</code-block>

        <h3>Route Parameters</h3>
        <code-block lang="markup">&lt;route path="/product/:id" methods="GET" /&gt;</code-block>
        <p>Access dynamic params in your component:</p>
        <code-block lang="javascript">connectedCallback() {
    console.log('Product ID:', this.params.id);
}</code-block>

        <h3>Attributes &amp; Observed Attributes</h3>
        <p>
          Standard DOM attributes are available via <code>this.getAttribute(name)</code>.
          To react to changes, declare <code>static get observedAttributes()</code>
          and implement <code>attributeChangedCallback</code>.
        </p>

        <p>These features let you combine routing, server-side handlers, and declarative attributes in SFC components.</p>
    </div>
</template>

<script lang="ts">
  export default {
    tag: "x-site",
    shadow: true,
    connectedCallback() {
      console.log("Component mounted with params:", this.params);
    }
  };
</script>

<style>
/* Rely on GlobalStyles.sfc for shared layout and pre/code styles.
   Keep only tiny component-specific overrides here. */
.hero { padding: 2rem; }
</style>

<route path="/site/" methods="GET" lazy="component" />
